<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="经验+总结">
<meta name="keywords" content="Unity，VR&#x2F;AR，UnityShader">
<meta property="og:type" content="website">
<meta property="og:title" content="我的独立博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="我的独立博客">
<meta property="og:description" content="经验+总结">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="我的独立博客">
<meta name="twitter:description" content="经验+总结">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>我的独立博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2012ab68f30f2a6afcb41a7e393fc4ea";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的独立博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">闲谈</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/10/C-常用关键字总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/10/C-常用关键字总结/" itemprop="url">C#常用关键字总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-10T19:20:59+08:00">
                2018-12-10
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/10/C-常用关键字总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/12/10/C-常用关键字总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><p>　　修饰类名为抽象类，如果一个类为抽象类，则这个类只能是其他某个类的基类，换句话说这个类不可以被实例化，只能用其子类实例化，当一个非抽象类继承该基类时，需要实现该基类中所有的抽象方法，抽象类继承则不必须。同时抽象类中可以存在其他非抽象方法。<br>　　修饰方法为抽象方法，抽象方法是隐式的虚方法，只能声明在抽象类中，且没有函数体。也不能使用static或者virtual修饰符。当然也不能用private修饰，因为私有的抽象方法不能被重写，毫无存在意义。</p>
<h4 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    abstract class _Abstract</span><br><span class="line">    &#123;</span><br><span class="line">        void _A() &#123; &#125;//非抽象方法</span><br><span class="line">        protected abstract void _AA();</span><br><span class="line">    &#125;</span><br><span class="line">    abstract class _AbstractSon1:_Abstract</span><br><span class="line">    &#123;//抽象类继承抽象类不需要做任何事，当然也可以</span><br><span class="line">     //实现父类的抽象方法</span><br><span class="line">        protected override void _AA()//此方法可写也可不写</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    class _AbstractSon2 :_AbstractSon1</span><br><span class="line">    &#123;</span><br><span class="line">       //若前面类实现了抽象方法，则其子类可不必须再次重写抽象方法</span><br><span class="line">       //当然也可以重写</span><br><span class="line">        protected override void _AA()//该方法不必须存在</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _AbstractSon3:_Abstract</span><br><span class="line">    &#123;</span><br><span class="line">        protected override void _AA()//该方法必须村子</span><br><span class="line">        &#123;</span><br><span class="line">            throw new NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h3><p>　　virtual 关键字用于修饰<strong>方法、属性、索引器或事件</strong>声明，并使它们可以在派生类中被重写。默认情况下，方法是非虚拟的。不能重写非虚方法。virtual 修饰符不能与 static、abstract, private 或 override 修饰符一起使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    class AProgram</span><br><span class="line">    &#123;</span><br><span class="line">        public virtual void AFun()//方法</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;父类的虚方法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public virtual event Action&lt;int&gt; a;//定义带一个参数的事件</span><br><span class="line">        public virtual string Current//属性</span><br><span class="line">        &#123;</span><br><span class="line">            get;set;</span><br><span class="line">        &#125;</span><br><span class="line">        int this[int index]//索引器</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Program : AProgram</span><br><span class="line">    &#123;</span><br><span class="line">        public override void AFun()//c重写</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;子类的虚方法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        public override event Action&lt;int&gt; a;//重写</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    class ProgramSon:Program</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            AProgram ap = new AProgram();</span><br><span class="line">            AProgram p = new Program();</span><br><span class="line">            AProgram pr = new Program();</span><br><span class="line">            AProgram ps = new ProgramSon();</span><br><span class="line">            ap.AFun();</span><br><span class="line">            p.AFun();</span><br><span class="line">            pr.AFun();</span><br><span class="line">            ps.AFun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://i.loli.net/2018/12/10/5c0e588e74ae6.png" alt=""></p>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>　　在Main方法中创建了四个AProgram对象，用这四个对象调用相同的AFun方法却不相同。下面来分析一下运行流程。</p>
<ul>
<li>ap.AFun()：先检查类AProgram中的AFun方法—检查到是虚拟方法—-转去检查实例类ap，就为本身–执行实例类ap中的方法—-输出结果：父类的虚方法  </li>
<li>p.AFun()和pr.AFun()：先检查类AProgram中的AFun方法—检查到是虚拟方法—转去检查实例类Program中是否有重写的—-执行实例类Program中的方法—-输出结果： 子类的虚方法  </li>
<li>ps.AFun()：先检查类AProgram中的AFun方法—检查到是虚拟方法—转去检查实例类ProgramSon是否有重写的—-没有重写的，去检查其父类Program中是否有重写的—执行实例类Program中的方法—-输出结果： 子类的虚方法  </li>
</ul>
<h4 id="分析来源"><a href="#分析来源" class="headerlink" title="分析来源"></a>分析来源</h4><p>　　虚拟函数从C#的程序编译的角度来看，它和其它一般的函数有什么区别呢？一般函数在编译时就静态地编译到了执行文件中，其相对地址在程序运行期间是不发生变化的，也就是写死了的！而虚函数在编译期间是不被静态编译的，它的相对地址是不确定的，它会根据运行时期对象实例来动态判断要调用的函数，其中那个申明时定义的类叫申明类，那个执行时实例化的类叫实例类。<br>如：飞禽 bird = new 麻雀();<br>那么飞禽就是申明类，麻雀是实例类。<br>具体的检查的流程如下</p>
<ul>
<li>当调用一个对象的函数时，系统会直接去检查这个对象申明定义的类，即申明类，看所调用的函数是否为虚函数；</li>
<li>如果不是虚函数，那么它就直接执行该函数。而如果有virtual关键字，也就是一个虚函数，那么这个时候它就不会立刻执行该函数了，而是转去检查对象的实例类。</li>
<li>在这个实例类里，他会检查这个实例类的定义中是否有重新实现该虚函数（通过override关键字），如果是有，那么OK，它就不会再找了，而马上执行该实例类中的这个重新实现的函数。而如果没有的话，系统就会不停地往上找实例类的父类，并对父类重复刚才在实例类里的检查，直到找到第一个重载了该虚函数的父类为止，然后执行该父类里重载后的函数。</li>
</ul>
<p>　　在上面的规则中，可以看到，如果子类没有override的修饰，那么就算父类是virtual的方法，子类的方法也无法被调用，而会去它的父类中找override的方法，直到找到祖先类。所以在面向对象的开发过程中，如果要实现Dependency Injection、IoC等设计模式，就必须非常留意类设计中继承方法的声明，否则很可能导致实际的程序运行与预期不符。</p>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>　　override 方法提供从基类继承的成员的新实现。</p>
<ul>
<li>由 override 声明重写的方法称为重写方法。重写的方法必须与 override 方法具有相同的签名。</li>
<li>重写的基方法必须是vitural,override,abstract类型的 ，不能重写非虚方法或是静态方法。所以override不能与vitural,new,static同时使用。</li>
<li>override 属性，声明必须指定与继承属性完全相同的访问修饰符、类型和名称，并且被重写的属性必须是 virtual、abstract 或 override 的。（注意：这里是属性，不是字段，字段是不能被重写的）。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    abstract class _Override</span><br><span class="line">    &#123;</span><br><span class="line">        public abstract int i;//错误，i是字段</span><br><span class="line">        public abstract int Current//抽象属性</span><br><span class="line">        &#123;</span><br><span class="line">            get;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        public abstract void oi();//方法</span><br><span class="line">        public virtual int Next//抽象字段</span><br><span class="line">        &#123;</span><br><span class="line">            get;</span><br><span class="line">            set;</span><br><span class="line">        &#125;</span><br><span class="line">        public abstract event Action&lt;int&gt; e;//抽象事件</span><br><span class="line">        public abstract int this[int index]//抽象索引器</span><br><span class="line">        &#123;</span><br><span class="line">            get;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _OverrideSon:_Override</span><br><span class="line">    &#123;</span><br><span class="line">        public override int Current &#123;</span><br><span class="line">            get =&gt; throw new NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">        public override event Action&lt;int&gt; e;</span><br><span class="line">        public override void oi()</span><br><span class="line">        &#123;</span><br><span class="line">            throw new NotImplementedException();</span><br><span class="line">        &#125;</span><br><span class="line">        public override int Next &#123;</span><br><span class="line">            get =&gt; base.Next;</span><br><span class="line">            set =&gt; base.Next = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override int this[int index] =&gt; </span><br><span class="line">            throw new NotImplementedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ul>
<li>创建一个对象，过于简单，这里不再叙述。</li>
<li>修饰方法，由于隐藏基类方法。</li>
<li>用在泛型中，表示该泛型参数T必须存在默认构造器，及无参数构造器。</li>
</ul>
<h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    class _New</span><br><span class="line">    &#123;</span><br><span class="line">        public void father()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;我是父亲&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _NewSon:_New</span><br><span class="line">    &#123;</span><br><span class="line">        public new void father()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;我是儿子&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _NewSon2:_New</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            _New s = new _NewSon2();</span><br><span class="line">            _New s1 = new _NewSon();</span><br><span class="line">            _New s2 = new _New();</span><br><span class="line">            _NewSon s4 = new _NewSon();</span><br><span class="line">            s.father();</span><br><span class="line">            s1.father();</span><br><span class="line">            s2.father();</span><br><span class="line">            s4.father();</span><br><span class="line">            _NewSon3&lt;_NewSon2&gt; n = new _NewSon3&lt;_NewSon2&gt;(2);//初始化成功，_NewSon3具有无参构造器</span><br><span class="line">            _NewSon3&lt;_NewSon4&gt; n2 = new _NewSon3&lt;_NewSon4&gt;(2);//初始化失败，_NewSon4不具有无参构造器</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _NewSon3&lt;T&gt; where T:new()//检查参数T类是否具有无参构造器</span><br><span class="line">    &#123;</span><br><span class="line">        public _NewSon3(int T)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _NewSon4</span><br><span class="line">    &#123;</span><br><span class="line">        public _NewSon4(int i)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h4><ul>
<li>s.father(); s1.father();s2.father();输出结果都为:我是父亲。多态下调用父类智能调用其自身所定义的方法和在其子类中重写的方法</li>
<li>n初始化成功，n2失败，因为_NewSon4不具有无参构造器。</li>
</ul>
<h3 id="sealed"><a href="#sealed" class="headerlink" title="sealed"></a>sealed</h3><ul>
<li>当对一个类应用sealed修饰符时，此修饰符会阻止其他类从该类继承。</li>
<li>sealed方法必须与override连用，密封方法重写基类中的方法，但其派生出的子类不能在进一步重写该方法。</li>
<li>sealed中不能定义新的虚成员（包括方法、属性、索引器、事件）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    class _Sealed</span><br><span class="line">    &#123;</span><br><span class="line">        public virtual void _A()</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sealed class _SealedSon:_Sealed</span><br><span class="line">    &#123;</span><br><span class="line">        public sealed override void _A()</span><br><span class="line">        &#123;</span><br><span class="line">            base._A();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _SealedSon1:_SealedSon//错误，不可以继承密封类</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    class _SealedSon2 : _Sealed//重写_A方法</span><br><span class="line">    &#123;</span><br><span class="line">        public override void _A()</span><br><span class="line">        &#123;</span><br><span class="line">            base._A();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _SealedSon3:_Sealed</span><br><span class="line">    &#123;</span><br><span class="line">        public sealed override void _A()//重写时使用sealed关键字</span><br><span class="line">        &#123;</span><br><span class="line">            base._A();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _SealedSon4:_SealedSon3</span><br><span class="line">    &#123;</span><br><span class="line">        public sealed override void _A()//因为_SealedSon3对_A重写时使用了sealed</span><br><span class="line">                                        //所以其_SealedSon4无法再次对_A重写</span><br><span class="line">        &#123;</span><br><span class="line">            base._A();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _SealedSon5:_SealedSon2</span><br><span class="line">    &#123;</span><br><span class="line">        public sealed override void _A()//普通就可以重写</span><br><span class="line">        &#123;</span><br><span class="line">            base._A();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>用来获取一个类的类型，和GetType()方法的功能类似，但二者又有一些不同点：</p>
<ul>
<li>Typeof不是运算符而是方法</li>
<li>GetType()是基类System.Object的方法，因此只有建立一个实例之后才能够被调用（初始化以后）</li>
<li>Typeof的参数只能是int,string,String,自定义类型，且不能是实例</li>
<li>GetType()和typeof都返回System.Type的引用.</li>
</ul>
<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    class _Typeof</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">             int i = 0;</span><br><span class="line">            Type type = typeof(int);//System.Int32;</span><br><span class="line">            // Type type1 = typeof(i);//错误</span><br><span class="line">            Type type2 = i.GetType();//</span><br><span class="line">            Console.WriteLine(type + &quot;  &quot; + type2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class _TypeofSon</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="params"><a href="#params" class="headerlink" title="params"></a>params</h3><p>　　params表示参数是可变个数的。在不加params修饰时，只能往里传入一个数组。调用方式1。在加了params后，不仅可以传入数组，还可以传入多个参数，这多个参数等价为数组。如调用方式2。<br>　　注意事项：</p>
<ul>
<li>params只能用在一维数组上，且必须是最后一个参数。</li>
<li>不能使用params来重载方法。因为重载是通过参数个数不同或者相同位置参数类型不同来区分的，这两种函数，函数的参数个数和参数类型都相同，所以不能区分。</li>
<li>不允许ref和out  与 params同时使用，加上之后程序编译时报错。因为数组的传递的本来就是引用（只限于用数组的方式进行调用）。</li>
<li>一个没有params的方法的优先级高于带有params的方法</li>
</ul>
<h4 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    class _Params</span><br><span class="line">    &#123;</span><br><span class="line">        public static void add(params int[] i)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;可变参数加法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void add(int i,int j)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;不可变参数加法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static void mix(int i,params int[] j)</span><br><span class="line">        &#123;//j必须放在i后边</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            _Params.add(new int[] &#123; &#125;);//方式一</span><br><span class="line">            _Params.add(2, 3);</span><br><span class="line">            _Params.add(1, 3, 4, 35, 35, 56);//方式二</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://i.loli.net/2018/12/11/5c0f196225ed2.png" alt=""></p>
<h3 id="is"><a href="#is" class="headerlink" title="is"></a>is</h3><p>　　用于强制类型转换，检查一个对象是否兼容于其指定的类型,并返回一个Bool值,永远不会抛出异常。一般使用方式如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    class _Is</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    class _IsSon:_Is</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            _IsSon i = new _IsSon();</span><br><span class="line">            if(i is _Is)</span><br><span class="line">            &#123;</span><br><span class="line">                _Is i1 = (_Is)i;</span><br><span class="line">                Console.WriteLine(&quot;转换成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，CLR实际上会检查两次对象的类型,is操作符先核实一次,如果i兼容于_Is,那么在(_Is)i时会再次核实一次,效率比较低,同时说明了is只是单纯的检查是否能够实现类型兼容，而不能转换。若要既检查又要实现转换可以用as。</p>
<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><p>用于强制类型转换，既会检查又可以实现转换,而且永远不会抛出异常,即如果转换不成功,会返回null。用法如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace SuanFa.KeyWord</span><br><span class="line">&#123;</span><br><span class="line">    class _As</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    class _AsSon:_As</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            _As i = new _AsSon();</span><br><span class="line">            _AsSon a = i as _AsSon;</span><br><span class="line">            if(a!=null)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;转换成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面的代码中，CLR只需要检查一次是否兼容，而且检查完毕后会执行相应的转换，比is效率高。</p>
<h3 id="partical"><a href="#partical" class="headerlink" title="partical"></a>partical</h3><p><a href="https://blog.csdn.net/yiyelanxin/article/details/70670074" target="_blank" rel="noopener">点这里</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/04/yield为什么可以实现迭代器功能/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/04/yield为什么可以实现迭代器功能/" itemprop="url">yield为什么可以实现迭代器功能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-04T09:55:25+08:00">
                2018-12-04
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/12/04/yield为什么可以实现迭代器功能/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/12/04/yield为什么可以实现迭代器功能/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="实现foreach遍历的两种方式"><a href="#实现foreach遍历的两种方式" class="headerlink" title="实现foreach遍历的两种方式"></a>实现foreach遍历的两种方式</h2><h3 id="使用IEnumerable-与-IEnumerator接口"><a href="#使用IEnumerable-与-IEnumerator接口" class="headerlink" title="使用IEnumerable 与 IEnumerator接口"></a>使用IEnumerable 与 IEnumerator接口</h3><p>　　首先先来了解一下这两个接口的含义，从名字常来看，IEnumerator是枚举器的意思，IEnumerable是可枚举的意思。接着看源码：</p>
<h4 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface IEnumerable</span><br><span class="line">&#123;</span><br><span class="line">    // Interfaces are not serializable</span><br><span class="line">    // Returns an IEnumerator for this enumerable Object.  The enumerator provides</span><br><span class="line">    // a simple way to access all the contents of a collection.</span><br><span class="line">    [Pure]</span><br><span class="line">    [DispId(-4)]</span><br><span class="line">    IEnumerator GetEnumerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface IEnumerator</span><br><span class="line">&#123;</span><br><span class="line">    // Interfaces are not serializable</span><br><span class="line">    // Advances the enumerator to the next element of the enumeration and</span><br><span class="line">    // returns a boolean indicating whether an element is available. Upon</span><br><span class="line">    // creation, an enumerator is conceptually positioned before the first</span><br><span class="line">    // element of the enumeration, and the first call to MoveNext </span><br><span class="line">    // brings the first element of the enumeration into view.</span><br><span class="line">    // </span><br><span class="line">    bool MoveNext();</span><br><span class="line"></span><br><span class="line">    // Returns the current element of the enumeration. The returned value is</span><br><span class="line">    // undefined before the first call to MoveNext and following a</span><br><span class="line">    // call to MoveNext that returned false. Multiple calls to</span><br><span class="line">    // GetCurrent with no intervening calls to MoveNext </span><br><span class="line">    // will return the same object.</span><br><span class="line">    // </span><br><span class="line">    Object Current &#123;</span><br><span class="line">        get; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Resets the enumerator to the beginning of the enumeration, starting over.</span><br><span class="line">    // The preferred behavior for Reset is to return the exact same enumeration.</span><br><span class="line">    // This means if you modify the underlying collection then call Reset, your</span><br><span class="line">    // IEnumerator will be invalid, just as it would have been if you had called</span><br><span class="line">    // MoveNext or Current.</span><br><span class="line">    //</span><br><span class="line">    void Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　IEnumerable中只有一个GetEnumerator函数，返回值是IEnumerator类型，所以实现了IEnumerable接口的类可以通过此方法获取一个IEnumerator枚举器，并通过此枚举器遍历这个类中包含的集合中的元素的功能（比如List<t>,ArrayList,Dictionary等继承了IEnumeratble接口的类）。</t></p>
<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa.IEnumerableInterface</span><br><span class="line">&#123;</span><br><span class="line">    class InheritIEnumerable : IEnumerable</span><br><span class="line">    &#123;</span><br><span class="line">        public int[] array = new int[] &#123; 1, 3, 4 &#125;;  </span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            InheritIEnumerable ii = new InheritIEnumerable();</span><br><span class="line">            Console.WriteLine(&quot;foreach执行结果：&quot;);</span><br><span class="line">            foreach (int i in ii)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;i=&quot; + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 返回IEnumerator类型的对象</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">        public IEnumerator GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;获取枚举器&quot;);</span><br><span class="line">            return new InheritIEnumerator(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class InheritIEnumerator : IEnumerator</span><br><span class="line">    &#123;</span><br><span class="line">        int[] array;</span><br><span class="line">        int pos = -1;</span><br><span class="line">        public InheritIEnumerator(int []array)</span><br><span class="line">        &#123;</span><br><span class="line">            this.array = array;</span><br><span class="line">        &#125;</span><br><span class="line">        public object Current</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;获取Current&quot;);</span><br><span class="line">                if (pos&lt;array.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    return array[pos];</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    throw new InvalidOperationException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public bool MoveNext()</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            if (pos&lt;array.Length-1)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;MoveNext true&quot;);</span><br><span class="line">                pos++;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(&quot;MoveNext false&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        public void Reset()</span><br><span class="line">        &#123;</span><br><span class="line">            pos = -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://i.loli.net/2018/12/04/5c05e990b7536.png" alt="">
　　</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>  通过输出结果，可以发现，foreach在运行时会先调用InheritIEnumerable的GetIEnumerator函数获取一个InheritIEnumerator实例（枚举器实例），之后通过循环调用InheritIEnumerator的MoveNext函数，pos后移，更新Current属性，然后返回Current属性，直到MoveNext返回false。<br>  总结一下：</p>
<ul>
<li>GetIEnumerator()负责获取枚举器。</li>
<li>MoveNext()负责让Current获取下一个值，并判断遍历是否结束。</li>
<li>Current负责返回当前指向的值。</li>
<li>Rest()负责重置枚举器的状态（在foreach中没有用到）</li>
</ul>
<p>这些就是IEnumerable，IEnumerator的基本工作原理。<br>　　所以foreach就相当于一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IEnumerable ieable = new InheritIEnumerable();</span><br><span class="line">            IEnumerator ie = ieable.GetEnumerator();</span><br><span class="line">while (ie.MoveNext())</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(ie.Current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用yield"><a href="#使用yield" class="headerlink" title="使用yield"></a>使用yield</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> class YieldFunctions</span><br><span class="line">&#123;</span><br><span class="line">    public static IEnumerable&lt;int&gt; getNums()</span><br><span class="line">    &#123;</span><br><span class="line">        yield return 1;</span><br><span class="line">        yield return 0;</span><br><span class="line">        yield return 3;</span><br><span class="line">        yield break;</span><br><span class="line">        yield return 5;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (int i in getNums())</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>yield return :返回迭代器的内容</li>
<li>yield break  ：终止迭代</li>
<li>yield只能使用在返回类型必须为 IEnumerable、IEnumerable”T”、IEnumerator 或 IEnumerator”T”的方法、运算符、get访问器中</li>
</ul>
<h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="https://i.loli.net/2018/12/04/5c05ec1433927.png" alt=""></p>
<h2 id="关键问题–使用yield迭代的时候我们虽然没有实现GetEnumerator-方法，也没有实现对应的IEnumerator的MoveNext-，和Current属性，但是我们仍然能正常使用foreach，换句话说也就是yield关键字在编译过程中会发生了什么？"><a href="#关键问题–使用yield迭代的时候我们虽然没有实现GetEnumerator-方法，也没有实现对应的IEnumerator的MoveNext-，和Current属性，但是我们仍然能正常使用foreach，换句话说也就是yield关键字在编译过程中会发生了什么？" class="headerlink" title="关键问题–使用yield迭代的时候我们虽然没有实现GetEnumerator()方法，也没有实现对应的IEnumerator的MoveNext()，和Current属性，但是我们仍然能正常使用foreach，换句话说也就是yield关键字在编译过程中会发生了什么？"></a>关键问题–使用yield迭代的时候我们虽然没有实现GetEnumerator()方法，也没有实现对应的IEnumerator的MoveNext()，和Current属性，但是我们仍然能正常使用foreach，换句话说也就是yield关键字在编译过程中会发生了什么？</h2><h3 id="YieldFunctions的IL代码"><a href="#YieldFunctions的IL代码" class="headerlink" title="YieldFunctions的IL代码"></a>YieldFunctions的IL代码</h3><p>先看一下YieldFunctions类的IL代码的整体框架，主要有三部分：getNums生成的IL代码，新生成的getNums类的IL代码，Main方法的IL代码。<br><img src="https://i.loli.net/2018/12/04/5c05ee246b56b.png" alt=""><br>接下来查看一下getNums方法生成的IL代码，可以返现在该方法中，创建了一个getNums类的对象，并将其作为返回值。<br><img src="https://i.loli.net/2018/12/04/5c05ef5dbbdad.png" alt=""><br>然后看一下生成的新的类getNums的代码：<br><img src="https://i.loli.net/2018/12/04/5c05f36ecfa54.png" alt=""><br><img src="https://i.loli.net/2018/12/04/5c05f371a2182.png" alt=""></p>
<p>再然后可以看一下MoveNext代码：<br><img src="https://i.loli.net/2018/12/04/5c05f4e0af73c.png" alt=""><br><img src="https://i.loli.net/2018/12/04/5c05f54817d0d.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>用yield来进行迭代的真实流程就是：<br>1.运行getNums()函数，获取代码自动生成的类的实例（IL代码中getNums类的实例）。<br>2.接着调用IL代码中GetEnumberator()函数，将获取的类自己作为迭代器开始迭代。<br>3.每次运行MoveNext()，state增加1，通过switch语句可以让每次调用MoveNext()的时候执行不同部分的代码。<br>4。MoveNext()返回false，结束。</p>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><ul>
<li>yield关键字其实是一种语法糖，最终还是通过实现IEnumberable”T”、IEnumberable、IEnumberator”T”和IEnumberator接口实现的迭代功能。</li>
<li>综上两种对foreach的实现原理，不管哪种方式，其最终原理还是一样的，只是体现了C#的封装性更好，对程序员更加友好，但为了更好的编程，还是需要了解这些原理。</li>
<li>可以说，如何可以使用foreach进行遍历的类，都需要直接或间接地实现IEnumerable接口，并返回IEnumerator枚举器对象进行遍历。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/30/C-、Java接口/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/30/C-、Java接口/" itemprop="url">C#、Java接口小知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-30T17:06:16+08:00">
                2018-11-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/30/C-、Java接口/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/30/C-、Java接口/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-接口"><a href="#C-接口" class="headerlink" title="C#接口"></a>C#接口</h2><h3 id="成员定义"><a href="#成员定义" class="headerlink" title="成员定义"></a>成员定义</h3><ul>
<li>接口内只可定义<strong>方法、属性、事件、索引器</strong>、不可以定义常量、字段、运算符、实例构造函数、析构函数或类型、不能包含静态成员。</li>
<li>接口成员是自动公开的，且不能包含任何访问修饰符，否则会报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface IProgramA</span><br><span class="line">&#123;</span><br><span class="line">    //属性</span><br><span class="line">    string Name</span><br><span class="line">    &#123;</span><br><span class="line">        get;set;</span><br><span class="line">    &#125;</span><br><span class="line">    //方法</span><br><span class="line">    void addFunc(int i, int j);</span><br><span class="line">    //索引器</span><br><span class="line">    int this[int i]</span><br><span class="line">    &#123;</span><br><span class="line">        get;</span><br><span class="line">    &#125;</span><br><span class="line">    //事件</span><br><span class="line">    event AddFunc af;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="成员实现"><a href="#成员实现" class="headerlink" title="成员实现"></a>成员实现</h3><ul>
<li>接口中的方法都是抽象方法，实现接口的任何非抽象类型都必须实现接口的所有成员：</li>
<li>当显式实现该接口的成员时，实现的成员不能通过类实例访问，只能通过接口实例访问。</li>
<li>当隐式实现该接口的成员时，实现的成员可以通过类实例访问，也可以通过接口实例访问，但是实现的成员必须是公有的。</li>
<li>一个类可以实现多个接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Indexer : IProgramA, IProgramB//实现多个接口</span><br><span class="line">&#123;</span><br><span class="line">    //实现属性,隐式实现</span><br><span class="line">    public string name;</span><br><span class="line">    public string Name</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            name = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //实现方法，隐式实现</span><br><span class="line">    public void addFunc(int i, int j)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;i+j=&quot; + (i + j));</span><br><span class="line">    &#125;</span><br><span class="line">    //实现索引器，隐式实现</span><br><span class="line">    int[] array = &#123; 2, 4, 53, 4, 5, 324 &#125;;</span><br><span class="line">    public int this[int i]</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            if (i &lt; array.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                return array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //实现事件，隐式实现</span><br><span class="line">    public event AddFunc af;</span><br><span class="line">    //实现另一个接口中的方法，显式实现</span><br><span class="line">    void IProgramB.funcB()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;显式实现的接口方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        //类的实例方法接口方法</span><br><span class="line">        Indexer id = new Indexer();</span><br><span class="line">        id.af += id.addFunc;</span><br><span class="line">        id.af(1, 2);</span><br><span class="line"></span><br><span class="line">        //接口的实例方法接口方法</span><br><span class="line">        IProgramA ia = new Indexer();</span><br><span class="line">        ia.addFunc(23, 23);</span><br><span class="line"></span><br><span class="line">        //funcB只可有IProgramB的实例调用</span><br><span class="line">        IProgramB ib = new Indexer();</span><br><span class="line">        ib.funcB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public delegate void AddFunc(int i, int j);</span><br><span class="line">interface IProgramA</span><br><span class="line">&#123;</span><br><span class="line">    //属性</span><br><span class="line">    string Name</span><br><span class="line">    &#123;</span><br><span class="line">        get;set;</span><br><span class="line">    &#125;</span><br><span class="line">    //方法</span><br><span class="line">    void addFunc(int i, int j);</span><br><span class="line">    //索引器</span><br><span class="line">    int this[int i]</span><br><span class="line">    &#123;</span><br><span class="line">        get;</span><br><span class="line">    &#125;</span><br><span class="line">    //事件</span><br><span class="line">    event AddFunc af;</span><br><span class="line">&#125;</span><br><span class="line">interface IProgramB</span><br><span class="line">&#123;</span><br><span class="line">    void funcB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h3><p><a href="https://www.cnblogs.com/jiajiayuan/archive/2011/09/16/2178462.html" target="_blank" rel="noopener">C#接口和C#抽象类联合使用</a></p>
<h2 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h2><h3 id="成员定义-1"><a href="#成员定义-1" class="headerlink" title="成员定义"></a>成员定义</h3><ul>
<li>接口中的所有属性 默认的修饰符是  public static final。</li>
<li>接口中的所有方法 默认的修饰符是  public abstract。</li>
</ul>
<h3 id="成员实现-1"><a href="#成员实现-1" class="headerlink" title="成员实现"></a>成员实现</h3><ul>
<li>和C#的类似</li>
</ul>
<h3 id="为什么是List-list-new-ArrayList，而不直接用ArrayList？"><a href="#为什么是List-list-new-ArrayList，而不直接用ArrayList？" class="headerlink" title="为什么是List list = new ArrayList，而不直接用ArrayList？"></a>为什么是List list = new ArrayList，而不直接用ArrayList？</h3><p><strong>主要考察面向对象的三大特征之一—-多态。同时也说明设计模型非常重要。解释如下：</strong><br>首先List有三个子类：ArrayList、LinkedList、Vector。当有如下声明时：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span>  ArrayList();</span><br></pre></td></tr></table></figure></p>
<p>此时的list是一个List对象，有些ArrayList有但是 List没有的属性和方法，它就不能再用了。但若是想要用LinkedList的实现来替代ArrayList的话，只需改动一行即可，其余代码基本不用管：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List   list   =   <span class="keyword">new</span>   LinkedList()；</span><br></pre></td></tr></table></figure></p>
<p>若声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list=new  ArrayList();</span><br></pre></td></tr></table></figure></p>
<p>此时list是一个ArrayList对象，它可以使用所有ArrayList的方法和属性，但若是想要使用LinkedList的实现来替代ArrayList的话就比较费事了，因为代码中可能使用了ArrayList独有的属性和方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/28/排序-冒泡排序法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/28/排序-冒泡排序法/" itemprop="url">冒泡排序法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-28T09:49:54+08:00">
                2018-11-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/28/排序-冒泡排序法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/28/排序-冒泡排序法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="排序示例"><a href="#排序示例" class="headerlink" title="排序示例"></a>排序示例</h3><p><img src="/排序--冒泡排序法/20191103105008283.png" alt=""></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>假设共有N个数，则需要遍历N - 1此，每次比较或交换的次数为N，则时间复杂度为O(N2)</li>
<li>交换过程中需要一个临时变量作为中介，所以空间复杂度为O(1)<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3></li>
<li>冒泡排序是稳定的算法，它满足稳定算法的定义。    </li>
<li>算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">namespace Algorithm.DataStructure.Sort</span><br><span class="line">&#123;</span><br><span class="line">    class BubbleSort:SortData</span><br><span class="line">    &#123;</span><br><span class="line">        public BubbleSort():base()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;-======================冒泡排序法=================================&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Sort(int[] array)</span><br><span class="line">        &#123;</span><br><span class="line">            base.Sort(array);</span><br><span class="line">            for(int i = array.Length - 1;i &gt; 0; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                for(int j = 0; j &lt; i - 1; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(array[j] &gt; array[j+1])</span><br><span class="line">                    &#123;</span><br><span class="line">                        int temp = array[j];</span><br><span class="line">                        array[j] = array[j + 1];</span><br><span class="line">                        array[j + 1] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="优化一"><a href="#优化一" class="headerlink" title="优化一"></a>优化一</h3><p>设置一个标志，如果这一趟发生了交换，则为false，否则为true。如果有一趟没有发生交换，说明排序已经完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void bubbleSort2()</span><br><span class="line">namespace Algorithm.DataStructure.Sort</span><br><span class="line">&#123;</span><br><span class="line">    class BubbleSort:SortData</span><br><span class="line">    &#123;</span><br><span class="line">        public BubbleSort():base()</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;-======================冒泡排序法=================================&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override void Sort(int[] array)</span><br><span class="line">        &#123;</span><br><span class="line">            base.Sort(array);</span><br><span class="line">            bool flag = false;</span><br><span class="line">            int k = array.Length - 1;</span><br><span class="line">            while(!flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = true;</span><br><span class="line">                for(int i = 0; i &lt; k ;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    if(array[i] &gt; array[i + 1])</span><br><span class="line">                    &#123;</span><br><span class="line">                        int temp = array[i];</span><br><span class="line">                        array[i] = array[i + 1];</span><br><span class="line">                        array[i + 1] = temp;</span><br><span class="line">                        flag = false;</span><br><span class="line">                    &#125;                </span><br><span class="line">                &#125;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="优化二"><a href="#优化二" class="headerlink" title="优化二"></a>优化二</h3><p>如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public void bubbleSort1()</span><br><span class="line">&#123;</span><br><span class="line">    int[] nums = &#123; 1, 2, 4, 34, 5345, 34, 43, 342 &#125;;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    int k = nums.Length - 1;</span><br><span class="line">    int pos = 0;</span><br><span class="line">    while (k&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = 0;</span><br><span class="line">        for(int i=0;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(nums[i]&gt;nums[i+1])</span><br><span class="line">            &#123;</span><br><span class="line">                pos = i;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i] = nums[i + 1];</span><br><span class="line">                nums[i + 1] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        k = pos;</span><br><span class="line">    &#125;</span><br><span class="line">    print(nums);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/23/C-委托的三种调用示例/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/23/C-委托的三种调用示例/" itemprop="url">C#委托的三种调用示例</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-23T09:45:02+08:00">
                2018-11-23
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/23/C-委托的三种调用示例/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/23/C-委托的三种调用示例/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h3><p><strong>运行描述</strong><br>委托的Invoke方法用来进行同步调用。同步调用也可以叫阻塞调用，它将阻塞当前线程，然后执行调用，调用完毕后再继续向下进行。<br><strong>运行代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa</span><br><span class="line">&#123;</span><br><span class="line">    public delegate int  AddDelegate(int i, int j);</span><br><span class="line">    class Delegate_Three</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Client application started!\n&quot;);</span><br><span class="line">            Thread.CurrentThread.Name = &quot;Main Thread&quot;;</span><br><span class="line">            Delegate_Three dt = new Delegate_Three();</span><br><span class="line">            AddDelegate ad = new AddDelegate(dt.Add);</span><br><span class="line">            int result=ad.Invoke(2, 5);</span><br><span class="line">            //int result =dt.Add(2, 5);</span><br><span class="line">            Console.WriteLine(&quot;Result: &#123;0&#125;\n&quot;, result);</span><br><span class="line">            // 做某些其它的事情，模拟需要执行3 秒钟</span><br><span class="line">            for (int i = 1; i &lt;= 3; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;: Client executed &#123;1&#125; second(s).&quot;,</span><br><span class="line">                    Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;\nPress any key to exit...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        public int Add(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            if (Thread.CurrentThread.IsThreadPoolThread)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.CurrentThread.Name = &quot;Pool Thread&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;Method invoked!&quot;);</span><br><span class="line">            // 执行某些事情，模拟需要执行2 秒钟</span><br><span class="line">            for (int i = 1; i &lt;= 2; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;: Add executed &#123;1&#125; second(s).&quot;, </span><br><span class="line">                    Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;Method complete!&quot;);</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果</strong><br><img src="https://i.loli.net/2018/11/23/5bf75bf8d2bb6.png" alt=""><br><strong>API</strong></p>
<ul>
<li><p>Thread.Sleep()，它会让执行当前代码的线程暂停一段时间（如果你对线程的概念比较陌生，可以理解为使程序的执行暂停一段时间），以毫秒为单位，比如Thread.Sleep(1000)，将会使线程暂停1 秒钟。在上面我使用了它的重载方法，个人觉得使用TimeSpan.FromSeconds(1)，可读性更好一些。</p>
</li>
<li><p>Thread.CurrentThread.Name，通过这个属性可以设置、获取执行当前代码的线程的名称，值得注意的是这个属性只可以设置一次，如果设置两次，会抛出异常。</p>
</li>
<li><p>Thread.IsThreadPoolThread，可以判断执行当前代码的线程是否为线程池中的线程。</p>
</li>
</ul>
<p>同步调用会阻塞线程，如果是要调用一项繁重的工作（如大量IO操作），可能会让程序停顿很长时间，造成糟糕的用户体验，这时候异步调用就很有必要了。</p>
<h3 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h3><p><strong>运行描述</strong><br>通常情况下，如果需要异步执行一个耗时的操作，我们会新起一个线程，然后让这个线程去执行代码。但是对于每一个异步调用都通过创建线程来进行操作显然会对性能产生一定的影响，同时操作也相对繁琐一些。.NET 中可以通过委托进行方法的异步调用，就是说客户端在异步调用方法时，本身并不会因为方法的调用而中断，而是从线程池中抓取一个线程去执行该方法，自身线程（主线程）在完成抓取线程这一过程之后，继续执行下面的代码，这样就实现了代码的并行执行。使用线程池的好处就是避免了频繁进行异步调用时创建、销毁线程的开销。当我们在委托对象上调用BeginInvoke()时，便进行了一个异步的方法调用。<br><strong>运行代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa</span><br><span class="line">&#123;</span><br><span class="line">    public delegate int  AddDelegate(int i, int j);</span><br><span class="line">    class Delegate_Three</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Client application started!\n&quot;);</span><br><span class="line">            Thread.CurrentThread.Name = &quot;Main Thread&quot;;</span><br><span class="line">            Delegate_Three dt = new Delegate_Three();</span><br><span class="line">            AddDelegate ad = new AddDelegate(dt.Add);</span><br><span class="line">            IAsyncResult asyncResult = ad.BeginInvoke(2, 5, null, null);</span><br><span class="line">            // 做某些其它的事情，模拟需要执行3 秒钟</span><br><span class="line">            for (int i = 1; i &lt;= 3; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;: Client executed &#123;1&#125; second(s).&quot;,</span><br><span class="line">                    Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">            int result = ad.EndInvoke(asyncResult);</span><br><span class="line">            Console.WriteLine(&quot;Result: &#123;0&#125;\n&quot;, result);</span><br><span class="line">            Console.WriteLine(&quot;\nPress any key to exit...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        public int Add(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            if (Thread.CurrentThread.IsThreadPoolThread)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.CurrentThread.Name = &quot;Pool Thread&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;Method invoked!&quot;);</span><br><span class="line">            // 执行某些事情，模拟需要执行2 秒钟</span><br><span class="line">            for (int i = 1; i &lt;= 2; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;: Add executed &#123;1&#125; second(s).&quot;, </span><br><span class="line">                    Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;Method complete!&quot;);</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果</strong><br><img src="https://i.loli.net/2018/11/23/5bf75dd310155.png" alt=""></p>
<p>可以看到，主线程并没有等待，而是直接向下运行了。但是问题依然存在，当主线程运行到EndInvoke时，如果这时调用没有结束（这种情况很可能出现），这时为了等待调用结果，线程依旧会被阻塞。<br>异步委托，也可以参考如下写法：<br>Action<object> action=(obj)=&gt;method(obj);<br>action.BeginInvoke(obj,ar=&gt;action.EndInvoke(ar),null);<br>简简单单两句话就可以完成一部操作。</object></p>
<h3 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h3><p><strong>运行描述</strong><br>用回调函数，当调用结束时会自动调用回调函数，解决了为等待调用结果，而让线程依旧被阻塞的局面。<br><strong>运行代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Runtime.Remoting.Messaging;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa</span><br><span class="line">&#123;</span><br><span class="line">    public delegate int  AddDelegate(int i, int j);</span><br><span class="line">    class Delegate_Three</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Client application started!\n&quot;);</span><br><span class="line">            Thread.CurrentThread.Name = &quot;Main Thread&quot;;</span><br><span class="line">            Delegate_Three dt = new Delegate_Three();</span><br><span class="line">            AddDelegate ad = new AddDelegate(dt.Add);</span><br><span class="line">            AsyncCallback asy = new AsyncCallback(dt.complete);</span><br><span class="line">            IAsyncResult asyncResult = ad.BeginInvoke(2, 5, asy, &quot;On Complete&quot;);</span><br><span class="line">            // 做某些其它的事情，模拟需要执行3 秒钟</span><br><span class="line">            for (int i = 1; i &lt;= 3; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;: Client executed &#123;1&#125; second(s).&quot;,</span><br><span class="line">                    Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;\nPress any key to exit...&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">        public void complete(IAsyncResult asyncResult)</span><br><span class="line">        &#123;</span><br><span class="line">            //AsyncResult是IAsyncResult的子类</span><br><span class="line">            AsyncResult asy = (AsyncResult)asyncResult;</span><br><span class="line">            AddDelegate ad = (AddDelegate)asy.AsyncDelegate;</span><br><span class="line">            string data = (string)asy.AsyncState;</span><br><span class="line">            int result = ad.EndInvoke(asyncResult);</span><br><span class="line">            Console.WriteLine(&quot;&#123;0&#125;: Result, &#123;1&#125;; Data: &#123;2&#125;\n&quot;, Thread.CurrentThread.Name, result, data);</span><br><span class="line">        &#125;</span><br><span class="line">        public int Add(int x, int y)</span><br><span class="line">        &#123;</span><br><span class="line">            if (Thread.CurrentThread.IsThreadPoolThread)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.CurrentThread.Name = &quot;Pool Thread&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;Method invoked!&quot;);</span><br><span class="line">            // 执行某些事情，模拟需要执行2 秒钟</span><br><span class="line">            for (int i = 1; i &lt;= 2; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread.Sleep(TimeSpan.FromSeconds(i));</span><br><span class="line">                Console.WriteLine(&quot;&#123;0&#125;: Add executed &#123;1&#125; second(s).&quot;, </span><br><span class="line">                    Thread.CurrentThread.Name, i);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(&quot;Method complete!&quot;);</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>运行结果</strong><br><img src="https://i.loli.net/2018/11/23/5bf76195a0cfa.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这里有几个值得注意的地方：</p>
<ul>
<li>我们在调用BeginInvoke()后不再需要保存IAysncResult 了，因为AysncCallback 委托将该对象定义在了回调方法的参数列表中；</li>
<li>我们在OnAddComplete()方法中获得了调用BeginInvoke()时最后一个参数传递的值，字符串“Any data you want to pass”；</li>
<li>执行回调方法的线程并非客户端线程Main Thread，而是来自线程池中的线程Pool Thread。另外如前面所说，在调用EndInvoke()时有可能会抛出异常，所以在应该将它放到try/catch 块中，这里就不再示范了。</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>问题：</p>
<ul>
<li><p>为什么Invoke的参数和返回值和AddDelegate委托是一样的呢？<br>答：Invoke方法的参数很简单，一个委托，一个参数表(可选)，而Invoke方法的主要功能就是帮助你在UI线程上调用委托所指定的方法。Invoke方法首先检查发出调用的线程(即当前线程)是不是UI线程，如果是，直接执行委托指向的方法，如果不是，它将切换到UI线程，然后执行委托指向的方法。不管当前线程是不是UI线程，Invoke都阻塞直到委托指向的方法执行完毕，然后切换回发出调用的线程(如果需要的话)，返回。<br>所以Invoke方法的参数和返回值和调用他的委托应该是一致的。</p>
</li>
<li><p>IAsyncResult result = ad.BeginInvoke(1,2,null,null);<br>BeginInvoke : 开始一个异步的请求,调用线程池中一个线程来执行，<br>返回IAsyncResult 对象(异步的核心). IAsyncResult 简单的说,他存储异步操作的状态信息的一个接口,也可以用他来结束当前异步。<br>注意:<strong> BeginInvoke和EndInvoke必须成对调用.即使不需要返回值，但EndInvoke还是必须调用，否则可能会造成内存泄漏。</strong></p>
</li>
<li><p>IAsyncResult.AsyncState 属性：<br>获取用户定义的对象，它限定或包含关于异步操作的信息。</p>
<h3 id="委托解析代码"><a href="#委托解析代码" class="headerlink" title="委托解析代码"></a>委托解析代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">.class public auto ansi sealed SuanFa.AddDelegate</span><br><span class="line">	extends [mscorlib]System.MulticastDelegate</span><br><span class="line">&#123;</span><br><span class="line">	// Methods</span><br><span class="line">	.method public hidebysig specialname rtspecialname </span><br><span class="line">		instance void .ctor (</span><br><span class="line">			object &apos;object&apos;,</span><br><span class="line">			native int &apos;method&apos;</span><br><span class="line">		) runtime managed </span><br><span class="line">	&#123;</span><br><span class="line">	&#125; // end of method AddDelegate::.ctor</span><br><span class="line"></span><br><span class="line">	.method public hidebysig newslot virtual </span><br><span class="line">		instance int32 Invoke (</span><br><span class="line">			int32 i,</span><br><span class="line">			int32 j</span><br><span class="line">		) runtime managed </span><br><span class="line">	&#123;</span><br><span class="line">	&#125; // end of method AddDelegate::Invoke</span><br><span class="line"></span><br><span class="line">	.method public hidebysig newslot virtual </span><br><span class="line">		instance class [mscorlib]System.IAsyncResult BeginInvoke (</span><br><span class="line">			int32 i,</span><br><span class="line">			int32 j,</span><br><span class="line">			class [mscorlib]System.AsyncCallback callback,</span><br><span class="line">			object &apos;object&apos;</span><br><span class="line">		) runtime managed </span><br><span class="line">	&#123;</span><br><span class="line">	&#125; // end of method AddDelegate::BeginInvoke</span><br><span class="line"></span><br><span class="line">	.method public hidebysig newslot virtual </span><br><span class="line">		instance int32 EndInvoke (</span><br><span class="line">			class [mscorlib]System.IAsyncResult result</span><br><span class="line">		) runtime managed </span><br><span class="line">	&#123;</span><br><span class="line">	&#125; // end of method AddDelegate::EndInvoke</span><br><span class="line"></span><br><span class="line">&#125; // end of class SuanFa.AddDelegate</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的代码用C#来写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public delegate int  AddDelegate(int i, int j);</span><br></pre></td></tr></table></figure></p>
<p>由此可以看出</p>
<ul>
<li>Invoke需要的参数列表与定义委托时的参数列表类型相同，返回值与委托的返回值类型相同。</li>
<li>BeginInvoke参数前两个为定义委托时的参数。第三个为AsyncCallback类型，该类型也是一个委托类型，用来定义异步调用执行完毕后的方法。第四个为object 类型，用来存储相关的信息，可以是任何信息。返回值为IAsyncResult类型，可以作为EndInvoke的入口参数</li>
<li>EndInvoke参数为IAsyncResult 类型，是一个接口类型。返回值就是委托的返回值。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/22/观察者模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/22/观察者模式/" itemprop="url">观察者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-22T22:03:43+08:00">
                2018-11-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/22/观察者模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/22/观察者模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h4><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p>
<h4 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h4><p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<h4 id="主要解决"><a href="#主要解决" class="headerlink" title="主要解决"></a>主要解决</h4><p>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<h4 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h4><p>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>使用面向对象技术，可以将这种依赖关系弱化。<strong>C#中可以使用委托来表现该种模式。</strong></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 观察者模式</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    /// &lt;param name=&quot;eb&quot;&gt;&lt;/param&gt;</span><br><span class="line">    public delegate void EventHandler(EventBase eb);</span><br><span class="line">    public class Delegate_Observe</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 已被注册事件，这里面的一些事件在某帧中将会被执行</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public Dictionary&lt;string, List&lt;EventHandler&gt;&gt; registedCallbacks </span><br><span class="line">            = new Dictionary&lt;string, List&lt;EventHandler&gt;&gt;();</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 在派发信息时新注册的事件，在下次派发时将被添加到registedCallbacks中。</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public Dictionary&lt;string, List&lt;EventHandler&gt;&gt; registedCallbacksPending </span><br><span class="line">            = new Dictionary&lt;string, List&lt;EventHandler&gt;&gt;();</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 是否正在执行registedCallbacks中的事件，为true时表示正在派发信息</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public bool isEnuming=false;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 派发过程中有收到新的需要派发的信息，下次派发前，将被添加到lEvents中</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public  List&lt;EventBase&gt; lPendingEvents = new List&lt;EventBase&gt;();//待处理事件</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 需要被派发的信息</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public  List&lt;EventBase&gt; lEvents = new List&lt;EventBase&gt;();//要处理事件</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 单例</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        static Delegate_Observe deob = new Delegate_Observe();</span><br><span class="line">        public static Delegate_Observe Deob</span><br><span class="line">        &#123;</span><br><span class="line">            get</span><br><span class="line">            &#123;</span><br><span class="line">                return deob;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 注册事件</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;eventName&quot;&gt;键值&lt;/param&gt;</span><br><span class="line">        /// &lt;param name=&quot;eh&quot;&gt;事件列表&lt;/param&gt;</span><br><span class="line">        public void registedEvent(string eventName,EventHandler eh)</span><br><span class="line">        &#123;</span><br><span class="line">            lock(this)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!registedCallbacks.ContainsKey(eventName))</span><br><span class="line">                &#123;</span><br><span class="line">                    registedCallbacks.Add(eventName, new List&lt;EventHandler&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;已注册该事件&quot;+eventName);</span><br><span class="line">                &#125;</span><br><span class="line">                if (isEnuming)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (!registedCallbacksPending.ContainsKey(eventName))</span><br><span class="line">                    &#123;</span><br><span class="line">                        registedCallbacksPending.Add(eventName, new List&lt;EventHandler&gt;());</span><br><span class="line">                    &#125;</span><br><span class="line">                    registedCallbacksPending[eventName].Add(eh);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                registedCallbacks[eventName].Add(eh);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 添加需要派发的信息</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;typeparam name=&quot;T&quot;&gt;信息的类型&lt;/typeparam&gt;</span><br><span class="line">        /// &lt;param name=&quot;value&quot;&gt;信息&lt;/param&gt;</span><br><span class="line">        public void Dispather&lt;T&gt;(T value) </span><br><span class="line">            where T:EventBase</span><br><span class="line">        &#123;</span><br><span class="line">            lock(this)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!registedCallbacks.ContainsKey(value.eventName))</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(&quot;未注册该事件&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (isEnuming)</span><br><span class="line">                &#123;</span><br><span class="line">                    lPendingEvents.Add(value);</span><br><span class="line">                    Console.WriteLine(&quot;添加为要事件&quot;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                foreach (EventBase eb in lPendingEvents)</span><br><span class="line">                &#123;</span><br><span class="line">                    lEvents.Add(eb);</span><br><span class="line">                &#125;</span><br><span class="line">                lPendingEvents.Clear();</span><br><span class="line">                lEvents.Add(value);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 每帧执行，派发信息</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        public void onTick()</span><br><span class="line">        &#123;</span><br><span class="line">            lock(this)</span><br><span class="line">            &#123;</span><br><span class="line">                if (lEvents.Count == 0)//没有需要处理的事件，查看是否有将要注册的事件,为派发做准备</span><br><span class="line">                &#123;</span><br><span class="line">                    foreach (string str in registedCallbacksPending.Keys)</span><br><span class="line">                    &#123;</span><br><span class="line">                        registedCallbacks.Add(str, registedCallbacksPending[str]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    registedCallbacksPending.Clear();</span><br><span class="line">                    foreach (EventBase eb in lPendingEvents)</span><br><span class="line">                    &#123;</span><br><span class="line">                        lEvents.Add(eb);</span><br><span class="line">                    &#125;</span><br><span class="line">                    lPendingEvents.Clear();</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                isEnuming = true;</span><br><span class="line">                foreach (EventBase eb in lEvents)</span><br><span class="line">                &#123;</span><br><span class="line">                    for (int i = 0; i &lt; registedCallbacks[eb.eventName].Count; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (registedCallbacks[eb.eventName][i] != null)</span><br><span class="line">                        &#123;</span><br><span class="line">                            registedCallbacks[eb.eventName][i](eb);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lEvents.Clear();</span><br><span class="line">            &#125;</span><br><span class="line">            isEnuming = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 信息基类</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class EventBase</span><br><span class="line">    &#123;</span><br><span class="line">        public string eventName;</span><br><span class="line">        public object value;</span><br><span class="line">        public EventBase(string eventName,object value)</span><br><span class="line">        &#123;</span><br><span class="line">            this.eventName = eventName;</span><br><span class="line">            this.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 信息子类</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    public class EventWithValue:EventBase</span><br><span class="line">    &#123;</span><br><span class="line">        public object value1;</span><br><span class="line">        public EventWithValue(string eventName,object value1)</span><br><span class="line">            :base(eventName,value1)</span><br><span class="line">        &#123;</span><br><span class="line">            this.eventName = eventName;</span><br><span class="line">            this.value1 = value1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public class Test</span><br><span class="line">    &#123;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 键值，每个键值对应一个事件列表</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        static string[] name = &#123; &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;K&quot; &#125;;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 注册线程执行方法，每隔一段事件就会注册新的事件，</span><br><span class="line">        /// 这些事件的目的是处理得到的信息</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        static void zhuce()</span><br><span class="line">        &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            while(true)</span><br><span class="line">            &#123;</span><br><span class="line">                if(index&gt;=name.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                Delegate_Observe.Deob.registedEvent(name[index], getSome);</span><br><span class="line">                Console.WriteLine(&quot;添加注册事件&quot;+ name[index]);</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.Sleep(1000);</span><br><span class="line">                &#125;</span><br><span class="line">                catch(Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(e.Data);</span><br><span class="line">                &#125;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 事件所对应的方法</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;eb&quot;&gt;&lt;/param&gt;</span><br><span class="line">        static void getSome(EventBase eb)</span><br><span class="line">        &#123;</span><br><span class="line">            EventWithValue ev = eb as EventWithValue;</span><br><span class="line">            int i = (int)ev.value1;</span><br><span class="line">            Console.WriteLine(ev.eventName + &quot; &quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        ///添加需要派发的信息的线程执行方法</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        static void yunxing()</span><br><span class="line">        &#123;</span><br><span class="line">            int index = 0;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.Sleep(1000);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(e.Data);</span><br><span class="line">                &#125;</span><br><span class="line">                if (index &gt;= name.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                EventWithValue ev = new EventWithValue(name[index], index);</span><br><span class="line">                Delegate_Observe.Deob.Dispather&lt;EventWithValue&gt;(ev);</span><br><span class="line">               </span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 派发信息的执行线程</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        static void diaoyong()</span><br><span class="line">        &#123;</span><br><span class="line">            while (true)</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    Thread.Sleep(500);</span><br><span class="line">                &#125;</span><br><span class="line">                catch (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(e.Data);</span><br><span class="line">                &#125;</span><br><span class="line">                Delegate_Observe.Deob.onTick();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            Thread s1 = new Thread(new ThreadStart(zhuce));</span><br><span class="line">            Thread s2 = new Thread(new ThreadStart(yunxing));</span><br><span class="line">            Thread s3 = new Thread(new ThreadStart(diaoyong));</span><br><span class="line">            s1.Start();</span><br><span class="line">            s2.Start();</span><br><span class="line">            s3.Start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h4><ul>
<li>线程s1：将某些方法注册到某个事件，当该事件触发时，其所注册的方法将按顺序全部执行</li>
<li>线程s2:添加需要派发的信息</li>
<li>线程s3：遍历需要派发的信息，并获得该信息中的键值，根据该键值获取相应的委托事件，并执行该事件，即调用处理信息的方法。</li>
<li>这三个线程主要是模拟观察者模式。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/14/UI穿透问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/UI穿透问题/" itemprop="url">UI穿透问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-14T19:31:11+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/14/UI穿透问题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/14/UI穿透问题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>　　在做unity的时候，有时候会受到UI穿透的影响，也就是两个UI图片重合了，本来是下方的UI图片是不能够被点击的，但是Unity默认下方UI图片可以被点击，这就需要编写相应方法来抵制这一现象。<br>    脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">public class DUIRayIgnore : MonoBehaviour, ICanvasRaycastFilter</span><br><span class="line">&#123;</span><br><span class="line">    public bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>该脚本主要是需要实现ICanvasRaycastFilter接口，并重写里面的IsRaycastLocationValid方法。将该脚本挂载在上一层方UI图片即可</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/Unity3d-UGUI-的多分辨率适配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/Unity3d-UGUI-的多分辨率适配/" itemprop="url">Unity3d + UGUI 的多分辨率适配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T20:10:35+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/12/Unity3d-UGUI-的多分辨率适配/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/12/Unity3d-UGUI-的多分辨率适配/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>实现<br><a href="https://blog.csdn.net/dingkun520wy/article/details/49471789" target="_blank" rel="noopener">点击这里</a></li>
<li>原理<br>　　如果目标设备的宽高比大于标准设备的宽高比，则按高来适配，否则按照宽来适配。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/面试之简答/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/面试之简答/" itemprop="url">面试之简答</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T18:37:14+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/12/面试之简答/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/12/面试之简答/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="点积和叉积的物理意义"><a href="#点积和叉积的物理意义" class="headerlink" title="点积和叉积的物理意义"></a>点积和叉积的物理意义</h3><p>　　<strong>点积</strong>:点积结果是个标量，主要用来求两个向量之间的夹角和一个向量在另一个向量上的投影（对于单位向量来讲）。<br>　　<strong>叉积</strong>:叉积结果是个标量，两个向量a，b相乘可以获得一个垂直于a，b的向量c。</p>
<h3 id="Unity组件删除和添加"><a href="#Unity组件删除和添加" class="headerlink" title="Unity组件删除和添加"></a>Unity组件删除和添加</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 添加</span><br><span class="line">GameObect.AddComponent&lt;ScriptName&gt;();</span><br><span class="line">2. 删除</span><br><span class="line">Destroy(GameObect.GetComponent&lt;ScriptName&gt;());</span><br></pre></td></tr></table></figure>
<h3 id="Unity3d获取游戏对象的几种方法"><a href="#Unity3d获取游戏对象的几种方法" class="headerlink" title="Unity3d获取游戏对象的几种方法"></a>Unity3d获取游戏对象的几种方法</h3><p><a href="https://www.cnblogs.com/qiaogaojian/p/6368274.html" target="_blank" rel="noopener">点击这里</a></p>
<h3 id="Unity3d中的碰撞器和触发器的区别"><a href="#Unity3d中的碰撞器和触发器的区别" class="headerlink" title="Unity3d中的碰撞器和触发器的区别"></a>Unity3d中的碰撞器和触发器的区别</h3><p>　碰撞器有碰撞的效果，IsTrigger=false，可以调用OnCollisionEnter/Stay/Exit函数； 触发器没有碰撞效果，IsTrigger=true，可以调OnTriggerEnter/Stay/Exit函数。</p>
<h3 id="脚本声明周期"><a href="#脚本声明周期" class="headerlink" title="脚本声明周期"></a>脚本声明周期</h3><p><a href="http://gad.qq.com/article/detail/29452" target="_blank" rel="noopener">点击这里</a><br>个人总结：主要的执行方法</p>
<ul>
<li>Reset：点击Inspector面板中的Reset按钮或者脚本第一次挂载在物体上时执行。</li>
<li>Awake：在预制件初始化之后，Start方法运行之前执行（物体在初始化时未被激活，该方法会在其被激活后执行）</li>
<li>OnEnable：在对象可用之后被调用，这通常发生在一个脚本的引用被创建时。</li>
<li>Start：若对象可用，在第一帧执行前调用。</li>
<li>FixUpdate：固定物理时间后调用，可能在一帧内调用多次，其执行时间间隔可通过修改Edit–ProjectSetting–Time面板中的timestep参数来改变。</li>
<li>yield WaitForFixUpdate：协程调用。</li>
<li>OnTriggerEnter/Stay/Exit：触发器执行的相应方法。</li>
<li>OnCollisionEnter/Stay/Exit:碰撞器执行方法</li>
<li>OnMouseEvent：鼠标监听执行事件</li>
<li>Update：每帧调用一次，是帧更新的主要函数。</li>
<li>yield null：协程调用</li>
<li>yield WaitForSeconds：协程调用</li>
<li>yield www:协程调用</li>
<li>yield StartCoroutine:协程调用</li>
<li>LateUpdate:所有Update函数调用完执行，通常用在第三人称更新摄像机位置。</li>
<li>OnPreCull：在相机剔除场景前被调用。剔除取决于物体在相机中是否可见。OnPreCull仅在剔除执行之前被调用。</li>
<li>OnBecameVisible/OnBecameInvisible：当物体在任何相机中可见/不可见时被调用。</li>
<li>OnWillRenderObject：如果物体可见，它将为每个摄像机调用一次。</li>
<li>OnPreRender： 在相机渲染场景之前被调用。</li>
<li>OnRenderObject：在所有固定场景渲染之后被调用。此时你可以使用GL类或者Graphics.DrawMeshNow来画自定义的几何体。</li>
<li>OnPostRender: 在相机完成场景的渲染后被调用。</li>
<li>OnRenderImage(仅专业版)：在场景渲染完成后被调用，用来对屏幕的图像进行后处理。</li>
<li>OnGUI：每帧执行多次来回应GUI事件。</li>
<li>yield WaitForEndOfFrame:协程调用</li>
<li>OnApplicationPause:若暂停被检测到，当前帧执行后就调用此函数，在正常的运行期间调用是有效的。在OnApplicationPause被调用后，额外的用一帧来显示图像表明暂停状态。</li>
<li>OnDisabled:对象不可用是执行</li>
<li>OnDestroy：这个函数在所有帧更新之后被调用，在对象存在的最后一帧（对象将销毁来响应Object.Destroy或关闭一个场景）。</li>
<li>OnApplicationQuit：在应用退出之前所有的游戏对象都会调用这个函数。在编辑器中当用户停止播放时它将被调用。<br><strong>也就是是说</strong>：一帧内执行一次的方法有：Update、协成调用（出WaitForFixUpdate外)、LateUpdate、Rendering方法（如OnRenderImage等等）。</li>
</ul>
<h3 id="Unity物体之间的通信"><a href="#Unity物体之间的通信" class="headerlink" title="Unity物体之间的通信"></a>Unity物体之间的通信</h3><p>主要是运用委托和事件</p>
<ul>
<li><a href="https://blog.csdn.net/beyonddeg/article/details/53528482" target="_blank" rel="noopener">第一篇</a></li>
<li><a href="https://blog.csdn.net/KingSea168/article/details/47701673" target="_blank" rel="noopener">第二篇</a></li>
<li><a href="http://gad.qq.com/article/detail/32480" target="_blank" rel="noopener">第三篇</a></li>
<li><a href="https://blog.csdn.net/cuit_xuchen/article/details/69789372" target="_blank" rel="noopener">第四篇</a><br>总结：首先要明白：</li>
<li>什么是委托：委托实质上是一个类，这个类实现了可以将方法作为参数进行传递，一个委托可以同时挂载多个方法，只是在运行时这些方法将按顺序全部执行</li>
<li>什么是事件：事件实质上是一个封装了的委托变量，封装了的含义是指：在类的内部，无论定义一个public还是protected类型的事件，其都是private类型的；在类的外部调用是，为其添加和删除的方法的访问修饰符必须与该事件的访问修饰符一样。</li>
<li>理解什么是观察者模式。利用该模式可以实现在物体对象之间传递消息，可以查看第一个链接的相关案例。</li>
</ul>
<h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><ul>
<li>定义：把一组数据结构和处理它们的方法组成<strong>对象</strong>（object），把相同行为的对象归纳为<strong>类</strong>（class），通过类的<strong>封装</strong>（encapsulation）隐藏内部细节，通过<strong>继承</strong>（inheritance）实现类的特化（specialization）／泛化（generalization），通过<strong>多态</strong>（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。</li>
<li><a href="https://blog.csdn.net/jiyiqinlovexx/article/details/46593053" target="_blank" rel="noopener">三大特性链接</a></li>
</ul>
<h3 id="bit和byte的定义及区别"><a href="#bit和byte的定义及区别" class="headerlink" title="bit和byte的定义及区别"></a>bit和byte的定义及区别</h3><p><a href="https://blog.csdn.net/panjunnn/article/details/5611241" target="_blank" rel="noopener">链接</a><br>个人总结：</p>
<ul>
<li>bit是计算机存储的单位，在二进制计算机中1bit为0或1，中文为比特，简写b</li>
<li>byte是计算机处理数据的单位，lbyte=8bit，中文为张字节，简写B</li>
<li>1kB=1024B=1024*8b</li>
</ul>
<h3 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h3><h3 id="MipMap作用及计算方法"><a href="#MipMap作用及计算方法" class="headerlink" title="MipMap作用及计算方法"></a>MipMap作用及计算方法</h3><ul>
<li>定义：Mipmap技术有点类似于LOD技术，但是不同的是，LOD针对的是模型资源，而Mipmap针对的纹理贴图资源。使用Mipmap后，贴图会根据摄像机距离的远近，选择使用不同精度的贴图。</li>
<li>缺点：会占用内存，因为mipmap会根据摄像机远近不同而生成对应的八个贴图，所以必然占内存！</li>
<li>优点：会优化显存带宽，用来减少渲染，因为可以根据实际情况，会选择适合的贴图来渲染，距离摄像机越远，显示的贴图像素越低，反之，像素越高！</li>
<li>用途：MipMap可以用于跑酷类游戏，当角色靠近时，贴图清晰显示，否则模糊显示如果我们使用的贴图不需要这样效果的话，就一定要把Generate Mip Maps选项和Read/Write Enabled选项取消勾选！因为Mipmap会十分占内存！</li>
<li>内存大小：Mipmap 会多占 1/3 内存。</li>
<li>多占内存原因：想要用数学求解，必须先了解 Mipmap 各个级别的尺寸大小是如何确定的，正常来说，Mipmap 会生成很多级别，每一级别的宽高都是上一个级别的 1/2，也就是说面积为上一个级别的 1/4，直到最终只有 1x1 分辨率的大小。<br>举个例子，一张 1024 x1024 的纹理，生成 Mipmap 后，会新产生 512  x 512，256  x256，128  x 128，64  x 64，32  x 32，16  x 16，8  x 8，4  x 4，2  x 2，1  x 1 这几张不同纹理级别的纹理。可以手动计算一下，新产生的纹理大小总和是 349525 个像素，而原来的 1024  x1024 纹理有 1048576 个像素，349525 / 1048576 约等于 0.33333302，也就是大约 1/3。</li>
<li><a href="https://zhuanlan.zhihu.com/p/36939174" target="_blank" rel="noopener">推理链接</a></li>
</ul>
<h3 id="C-常用容器及其数据结构"><a href="#C-常用容器及其数据结构" class="headerlink" title="C#常用容器及其数据结构"></a>C#常用容器及其数据结构</h3><ul>
<li>Array： 属于System命名空间。<strong>数组</strong>，在内存中是连续存储的，所以它的索引速度非常快，但是插入删除比较慢。</li>
<li><p>ArrayList：是命名空间System.Collections下的一部分，在使用该类时必须进行引用，同时继承了IList接口，提供了数据存储和检索。ArrayList对象的大小是按照其中存储的数据来动态扩充与收缩的。所以，在声明ArrayList对象时并不需要指定它的长度。<strong>ArrayList会把所有插入其中的数据当作为object类型来处理，在我们使用ArrayList处理数据时，存在装箱和拆箱操作，会损失性能。其底层数据结构使用的是object类型数组</strong>。类似于C++中的Vector，类似于java中ArrayList和Vector</p>
</li>
<li><p>List“T”:包含在System.Collections.Generic命名空间中，<strong>底层数据结构就是数组</strong>，但是存取数据避免了拆箱和装箱操作，类似于C++里面的Vector“T”。</p>
</li>
<li>LinkedList：包含在 System.Collections.Generic命名空间中，<strong>双向链表</strong>，LinkedList“T”提供 LinkedListNode“T” 类型的单独节点，因此插入和移除的运算复杂度为 O(1)。可以移除节点，然后在同一列表或其他列表中重新插入它们，这样在堆中便不会分配额外的对象。由于该列表还维护内部计数，因此获取 Count 属性的运算复杂度为 O(1)。LinkedList“T”  对象中的每个节点都属于 LinkedListNode“T”  类型。由于 LinkedList“T” 是双向链表，因此每个节点向前指向 Next 节点，向后指向 Previous 节点。类似于java中的LinkedList</li>
<li>HashSet：属于System.Collections.Generic命名空间。HashSet“T”类提供了高性能的集运算。一组是一个集合，不包含任何重复的元素，且的元素顺序不分先后。用了hash table来储存数据，是为了用O(n)的space来换取O(n)的时间，也就是查找元素的时间是O(1)。<strong>底层使用的是哈希表</strong>，类似于java中的Set“T”。</li>
<li>HashTable:Hashtable是System.Collections命名空间提供的一个容器，用于处理和表现类似key/value的键值对，其中key通常可用来快速查找，同时key是区分大小写；value用于存储对应于key的值。Hashtable中key/value键值对均为object类型，所以Hashtable可以支持任何类型的key/value键值对。所以用的存取的时候存在装箱和拆箱操作。<strong>底层使用的是哈希表</strong>，类似于java中的HashMap，HashTable</li>
<li>Dictionary：包含在System.Collections.Generic命名空间下。也是键值容器，存入对象是需要与[key]值一一对应的存入该泛型。相对于HashTable，存取时不需要拆箱和装箱出走。<strong>底层使用的是哈希表</strong></li>
<li>java中改的TreeMap、TreeSet和c++中的hashMap为红黑树</li>
</ul>
<p><strong>总结：</strong>C#所有泛型容器都在System.Collections.Generic命名空间下，非泛型容器在System.Collections空间下。</p>
<ul>
<li>C#链接：<ul>
<li><a href="https://blog.csdn.net/silangquan/article/details/51106968" target="_blank" rel="noopener">链接一</a></li>
</ul>
</li>
<li>java链接：<ul>
<li><a href="https://blog.csdn.net/qq_29631809/article/details/72599708" target="_blank" rel="noopener">基础</a></li>
<li><a href="https://blog.csdn.net/xy2953396112/article/details/54891527" target="_blank" rel="noopener">进阶</a></li>
</ul>
</li>
</ul>
<h3 id="数组和链表内存上的区别"><a href="#数组和链表内存上的区别" class="headerlink" title="数组和链表内存上的区别"></a>数组和链表内存上的区别</h3><ul>
<li>数组是连续内存，索引查找比较快，添加删除比较慢，因为需要移动后面的元素</li>
<li>链表是不连续内存，添加删除比较快，查找比较慢，因为需要从头查找</li>
</ul>
<h3 id="Java和C-泛型区别"><a href="#Java和C-泛型区别" class="headerlink" title="Java和C#泛型区别"></a>Java和C#泛型区别</h3><p>C#泛型无论实在源码中、编译后的IL文件中（Intermediate Language，中间语言，这时候泛型是一个占位符），还是在运行期的CLR中都是切实存在的，也就是List<int>与List<string>就是两个不同的类<br>型。而Java泛型只是在源码中存在，在编译后的字节码中，就已经被替换为了原始类型，并在相应地方插入了强制类型转换，因此对于运行期的Java语言来说，ArrayList<int>与ArrayList<string>就是同一个类。所以C#是真泛型，Java是假泛型。</string></int></string></int></p>
<h3 id="C-运行流程"><a href="#C-运行流程" class="headerlink" title="C#运行流程"></a>C#运行流程</h3><p>（1）C#编译器先将源代码编译成IL文件和元数据，并连同其他资源文件合并成程序集，程序集的可执行文件存储在磁盘上，通常具有的扩展名为 .exe 或 .dll（编译阶段）。<br>（2）程序集合并完成后，若程序集可执行，在Main(）方法执行之前，window开启一个进程，并再加载MSCOREE.DLL,然后进程的主线程会调用MSCOREE.DLL中的方法初始化CLR（公共语言运行库），CLR中JIT（即时编译）会把IL语言转换为cpu指令（也称及其指令），并以文件方式存储在硬盘上，操作系统将文件从硬盘读入内存，CPU从内从取出指令执行（运行阶段）。<br><strong>延伸：</strong><br>（1）开发者编写的代码编译后，不依赖于操作系统和特定的CPU架构机器指令，而是依赖于一种中间的，在各个操作系统上都能执行的代码，这种代码Java里面叫做ByteCode（字节码），.NET里面我们称之为MSIL指令（微软中间语言）。<br>（2）不管是Java的字节码还是.NET的MSIL指令仍然需要最终被翻译成CPU能够执行的机器指令。这个功能是由一个运行在特定操作系统上的软件来完成，这个软件我们称之为“虚拟机”。</p>
<h3 id="C-内存结构"><a href="#C-内存结构" class="headerlink" title="C#内存结构"></a>C#内存结构</h3><p>C#主要由内存主要分为内存主要分为三类：</p>
<ul>
<li>栈内存：主要用于存储值类型数据</li>
<li>SOH堆:存储小的引用对象</li>
<li>LOH堆：存储大对象，主要是大小大于85000字节的对象</li>
</ul>
<h3 id="C-中GC运行时间"><a href="#C-中GC运行时间" class="headerlink" title="C#中GC运行时间"></a>C#中GC运行时间</h3><p>个人总结：</p>
<ul>
<li>托管堆：CLR初始化后，会保留一块连续内存，这就是托管堆。</li>
<li>简要流程：C#编译器遇到new指令时，会在IL中添加一条newobj指令，CLR遇到该指令会计算该对象的大小，然后计算堆中是否存在该大小的内存，若存在，则直接分配相应大小的内存，并调用对象的构造函数将对象放在这块内存中，若不存在则需要执行相应的垃圾回收。</li>
<li>垃圾回收时，垃圾回收器会首先认为堆中的所有对象都是垃圾，然后挨个遍历应用程序根列表（需要单独介绍应用程序根，列表由JIT编译器和CLR编译器进行维护，垃圾回收器可以访问这些对象）和引用对象，并构建一个由应用程序根和其所指向对象构成的图，由此可判断哪些对象是可达的，可达的话，就会标记此对象，若此对象已被标记，则不会再对其进行标记。（也就是根据这些应用程根，查看根所指向的内存地址，这块地址中存储的对象就是可达的，还会被引用，所以会被标记）。</li>
<li>标记完毕后，垃圾回收器会遍历堆中的对象，未被标记的对象则会被当成垃圾释放其内存。并将不是垃圾的对象移到一起，消除内存碎片。</li>
<li>注意，在移动可达对象之后，所有引用这些对象的变量将无效，接着垃圾回收器要重新遍历应用程序的所有根来修改它们的引用。在这个过程中如果各个线程正在执行，很可能导致变量引用到无效的对象地址，所以整个进程的正在执行托管代码的线程是被挂起的。<br><strong>应用程序根：</strong></li>
<li>全局对象和静态对象的引用</li>
<li>应用程序代码库中局部对象的引用</li>
<li>传递进一个方法的对象参数的引用</li>
<li>等待被终结（finalize）对象的引用</li>
<li>任何引用对象的CPU寄存器<br><strong>垃圾回收在下列情况下发生：</strong></li>
</ul>
<ol>
<li>申请的空间超过0代内存大小或者大对象堆的阀值，多数的托管堆垃圾回收在这种情况下发生</li>
<li>在程序代码中调用GC.Collect方法时；如果在调用GC.Collect方法是传入GC.MaxGeneration参数时，会执行所有代对象的垃圾回收，包括大对象堆的垃圾回收</li>
<li>操作系统内存不足时，当应用程序收到操作系统发出的高内存通知时</li>
<li>如果垃圾回收算法认为做二代回收是有收效时会触发二代垃圾回收</li>
<li>每一代对象堆的都有一个所占空间大小阀值的属性，当你分配对象到某一代，你增长了内存总量接近了该代的阀值，或者分配对象导致这一代的堆大小超过了堆阀值，就会发生一次垃圾回收。因此当你分配小对象或者大对象时，会对应消耗0代堆或者大对象堆的阀值。当垃圾回收器将对象代数提升到1代或者2代时，会消耗1、2代的阀值。在程序运行中这些阀值是动态变化的。（动态变化，也就是垃圾回收过程中，0,1,2代垃圾的可使用内存不断变化）<br><strong>垃圾回收是分代的：</strong></li>
</ol>
<ul>
<li>0代：从没有被标记为回收的新分配的对象</li>
<li>1代：在上一次垃圾回收中没有被回收的对象</li>
<li>2代：在一次以上的垃圾回收后仍然没有被回收的对象</li>
<li>每代垃圾存储超过其最大值都会触发垃圾回收。</li>
<li>第0,1代大约16M左右，第二代是根据应用程序不断变化的，可达几GB。<br>链接：<br><a href="https://www.cnblogs.com/wilber2013/p/4357910.html" target="_blank" rel="noopener">重点一</a><br><a href="https://www.cnblogs.com/yukaizhao/archive/2011/11/21/dot_net_gc_large_object_heap.html" target="_blank" rel="noopener">重点二</a></li>
</ul>
<h3 id="垃圾回收方式"><a href="#垃圾回收方式" class="headerlink" title="垃圾回收方式"></a>垃圾回收方式</h3><ul>
<li>托管对象会被CLR自动回收，如分配在堆中的对象和分配在栈中的变量</li>
<li>通过调用GC.Collect()方法，强制垃圾回收，不推荐使用</li>
<li>通过析构函数，即finalize函数。</li>
<li>实现IDispose接口</li>
<li>析构函数和IDispose接口共同使用<h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><h3 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a>结构体和类的区别</h3><h3 id="值类型和引用类型区别"><a href="#值类型和引用类型区别" class="headerlink" title="值类型和引用类型区别"></a>值类型和引用类型区别</h3><h3 id="重载和重写区别"><a href="#重载和重写区别" class="headerlink" title="重载和重写区别"></a>重载和重写区别</h3></li>
<li>重载是对于同一类中的方法来讲：有相同的方法名，相同的返回值，只是参数不同</li>
<li>重写是对继承来说，子类可以重写父类中的方法。要求方法名，返回值，参数都必须相同。</li>
</ul>
<h3 id="协成和线程"><a href="#协成和线程" class="headerlink" title="协成和线程"></a>协成和线程</h3><ul>
<li>协成：在主线程运行时同时开启另一段逻辑处理，来协助当前程序的执行。换句话说，开启协程就是开启一个可以与程序并行的逻辑。可以用来控制运动、序列以及对象的行为。</li>
<li>协成同一时间只可以有一个运行，协成还是在主线程中运行（从脚本执行流程中可以找到），线程可以并发执行，</li>
</ul>
<h3 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h3><h3 id="yield返回值"><a href="#yield返回值" class="headerlink" title="yield返回值"></a>yield返回值</h3><ul>
<li>WaitForEndOfFrame，顾名思义是在等到本帧的帧末进行在进行处理，这个问题不大，比较不容易搞错</li>
<li>yield return null/任何数字：暂缓一帧，协程在下一帧的所有Update函数调用后继续执行。</li>
<li>yield return new WaitForSeconds：在一个指定的时间延迟后继续执行，在所有的Update函数被调用之后。（这个要注意的是1·实际时间等于给定的时间乘以Time.timeScale的值。2·触发间隔一定大等于1中计算出的实际时间，而且误差的大小取决于帧率，因为它是在每帧处理协程的时候去计算时间间隔是否满足条件，如果满足则继续执行。例如，当帧率为5的情况下，一帧的时间为200ms，这时即使时间参数再小，最快也要200ms之后才能继续执行剩余部分。）</li>
<li>yield WaitForFixedUpdate()：在所有脚本上所有的FixedUpdate被调用之后继续执行。</li>
<li>yield WWW：在WWW加载完成之后继续执行。</li>
<li>yield StartCoroutine(MyFunc)：用于链接协程，此将等待MyFunc协程完成先。</li>
</ul>
<h3 id="foreach实现"><a href="#foreach实现" class="headerlink" title="foreach实现"></a>foreach实现</h3><p><a href="https://blog.csdn.net/dk_0520/article/details/68946830" target="_blank" rel="noopener">点击这里</a><br>个人总结：首先要实现IEnumerable接口，并实现里面的GetEnumerator方法，GetEnumerator方法返回的是一个实例化的IEnumerator遍历器，IEnumerator中包含两个属性。</p>
<ul>
<li>Current，就是返回这个遍历工具所指向的那个容器的当前的元素。</li>
<li>MoveNext 方法就是指向下一个元素，当遍历到最后没有元素时，返回一个false。</li>
</ul>
<p>所以还需要一个实现了IEnumerator接口的类。<br>（或者在GetEnumerator方法中使用yield return）。</p>
<h3 id="private、protected、public、internal区别"><a href="#private、protected、public、internal区别" class="headerlink" title="private、protected、public、internal区别"></a>private、protected、public、internal区别</h3><ul>
<li>private是完全私有的，只有在类自己里面可以调用，在类的外部和子类都不能调用，子类也不能继承父类的private的属性和方法</li>
<li>protected虽然可以被外界看到，但外界却不能调用，只有自己及自己的子类可以调用（protected的属性和方法都可以被子类所继承和调用）。</li>
<li>public对任何类和成员都完全公开，无限制访问</li>
<li>internal同一应用程序集内部（在VS.NET中的一个项目中，这里的项目是指单独的项目，而不是整个解决方案）可以访问。</li>
</ul>
<h3 id="接口和类的区别"><a href="#接口和类的区别" class="headerlink" title="接口和类的区别"></a>接口和类的区别</h3><ul>
<li><p>抽象类可以有构造方法，接口中不能有构造方法。</p>
</li>
<li><p>抽象类中可以有普通成员变量，接口中没有普通成员变量</p>
</li>
<li><p>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</p>
</li>
<li><p>抽象类中的抽象方法的访问类型可以是public，protected，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</p>
</li>
<li><p>抽象类中可以包含静态方法，接口中不能包含静态方法</p>
</li>
<li><p>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</p>
</li>
<li><p>一个类可以实现多个接口，但只能继承一个抽象类。</p>
</li>
<li><p>接口可以用于支持回调,而继承并不具备这个特点.   </p>
</li>
<li>抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的.  </li>
</ul>
<h3 id="Unity其他相关面试题"><a href="#Unity其他相关面试题" class="headerlink" title="Unity其他相关面试题"></a>Unity其他相关面试题</h3><p><a href="http://gad.qq.com/article/detail/20995" target="_blank" rel="noopener">100道</a></p>
<h3 id="线程池相关"><a href="#线程池相关" class="headerlink" title="线程池相关"></a>线程池相关</h3><p><a href="https://www.cnblogs.com/kissdodog/archive/2013/03/26/2983755.html" target="_blank" rel="noopener">共七篇</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/面试总结之算法题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wangzhuanxu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的独立博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/12/面试总结之算法题/" itemprop="url">面试总结之算法题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T16:22:35+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/12/面试总结之算法题/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/11/12/面试总结之算法题/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="两个栈实现一个队列"><a href="#两个栈实现一个队列" class="headerlink" title="两个栈实现一个队列"></a>两个栈实现一个队列</h2><ul>
<li>思路<br>入队：将元素进栈A<br>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。 </li>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();</span><br><span class="line">    public void push(int node) &#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    public int pop() &#123;</span><br><span class="line">        int i;</span><br><span class="line">        if(stack2.size()&lt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            while(stack1.size()&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i=stack2.pop();</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="两个队列实现一个栈"><a href="#两个队列实现一个栈" class="headerlink" title="两个队列实现一个栈"></a>两个队列实现一个栈</h2><ul>
<li>思路<br>入栈：将元素进队列A<br>出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素   以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把   队列B中的元素出队列以此放入队列A中。</li>
<li>代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Stacks</span><br><span class="line">&#123;</span><br><span class="line">    Queue&lt;int&gt; q1 = new Queue&lt;int&gt;();</span><br><span class="line">    Queue&lt;int&gt; q2 = new Queue&lt;int&gt;();</span><br><span class="line">    public void push(int node)</span><br><span class="line">    &#123;</span><br><span class="line">        q1.Enqueue(node);</span><br><span class="line">    &#125;</span><br><span class="line">    public int  pop()</span><br><span class="line">    &#123;</span><br><span class="line">        if(q1.Count&lt;=0)</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        while(q1.Count&gt;1)</span><br><span class="line">        &#123;</span><br><span class="line">            q2.Enqueue(q1.Dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        int j = q1.Dequeue();</span><br><span class="line">        while(q2.Count&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            q1.Enqueue(q2.Dequeue());</span><br><span class="line">        &#125;</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二叉树的四种遍历"><a href="#二叉树的四种遍历" class="headerlink" title="二叉树的四种遍历"></a>二叉树的四种遍历</h2><ul>
<li>图解链接<br><a href="https://www.cnblogs.com/isabelle/p/isabellezhou.html" target="_blank" rel="noopener">图解链接</a></li>
<li>实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line">namespace SuanFa</span><br><span class="line">&#123;</span><br><span class="line">    //树的遍历</span><br><span class="line">    class TraverseTree</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            Tree A = new Tree(&quot;A&quot;);</span><br><span class="line">            Tree B = new Tree(&quot;B&quot;);</span><br><span class="line">            Tree C = new Tree(&quot;C&quot;);</span><br><span class="line">            Tree D = new Tree(&quot;D&quot;);</span><br><span class="line">            Tree E = new Tree(&quot;E&quot;);</span><br><span class="line">            Tree F = new Tree(&quot;F&quot;);</span><br><span class="line">            Tree G = new Tree(&quot;G&quot;);</span><br><span class="line">            Tree H = new Tree(&quot;H&quot;);</span><br><span class="line">            Tree I = new Tree(&quot;I&quot;);</span><br><span class="line">            A.left = B;</span><br><span class="line">            A.right = C;</span><br><span class="line">            B.left = D;</span><br><span class="line">            B.right = F;</span><br><span class="line">            F.left = E;</span><br><span class="line">            C.left = G;</span><br><span class="line">            C.right = I;</span><br><span class="line">            G.right = H;</span><br><span class="line">            TraverseTree tt = new TraverseTree();</span><br><span class="line">            Console.WriteLine(&quot;先序遍历：&quot;);</span><br><span class="line">            tt.preOrder1(A);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            tt.preOrder2(A);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;中序遍历：&quot;);</span><br><span class="line">            tt.inOrder1(A);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            tt.inOrder2(A);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;后序遍历：&quot;);</span><br><span class="line">            tt.posOrder1(A);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            tt.posOrder2(A);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            Console.WriteLine(&quot;层序遍历：&quot;);</span><br><span class="line">            tt.levelOrder(A);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 先序遍历，递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;根节点&lt;/param&gt;</span><br><span class="line">        public void preOrder1(Tree root)</span><br><span class="line">        &#123;</span><br><span class="line">            if(root==null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.Write(root.node + &quot; &quot;);</span><br><span class="line">            preOrder1(root.left);</span><br><span class="line">            preOrder1(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 先序遍历，非递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;根节点&lt;/param&gt;</span><br><span class="line">        public void preOrder2(Tree root)</span><br><span class="line">        &#123;</span><br><span class="line">            Stack&lt;Tree&gt; s = new Stack&lt;Tree&gt;();</span><br><span class="line">            Tree t = root;</span><br><span class="line">            while(t!=null||s.Count&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                if(t!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(t.node + &quot; &quot;);</span><br><span class="line">                    s.Push(t);</span><br><span class="line">                    t = t.left;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    t = s.Pop();</span><br><span class="line">                    t = t.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 中序遍历，递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;根节点&lt;/param&gt;</span><br><span class="line">        public void inOrder1(Tree root)</span><br><span class="line">        &#123;</span><br><span class="line">            if (root == null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            inOrder1(root.left);</span><br><span class="line">            Console.Write(root.node + &quot; &quot;);</span><br><span class="line">            inOrder1(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 中序遍历，非递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;根节点&lt;/param&gt;</span><br><span class="line">        public void inOrder2(Tree root)</span><br><span class="line">        &#123;</span><br><span class="line">            Stack&lt;Tree&gt; s = new Stack&lt;Tree&gt;();</span><br><span class="line">            Tree t = root;</span><br><span class="line">            while (t != null || s.Count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (t != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    s.Push(t);</span><br><span class="line">                    t = t.left;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    t = s.Pop();</span><br><span class="line">                    Console.Write(t.node + &quot; &quot;);</span><br><span class="line">                    t = t.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 后序遍历，递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;根节点&lt;/param&gt;</span><br><span class="line">        public void posOrder1(Tree root)</span><br><span class="line">        &#123;</span><br><span class="line">            if (root == null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            posOrder1(root.left);</span><br><span class="line">            posOrder1(root.right);</span><br><span class="line">            Console.Write(root.node + &quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 后序遍历，非递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;根节点&lt;/param&gt;</span><br><span class="line">        public void posOrder2(Tree root)</span><br><span class="line">        &#123;</span><br><span class="line">            Stack&lt;Tree&gt; s = new Stack&lt;Tree&gt;();</span><br><span class="line">            Tree t = root;</span><br><span class="line">            Tree pre = null;</span><br><span class="line">            while (t != null || s.Count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                while(t!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    s.Push(t);</span><br><span class="line">                    t = t.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                t = s.Peek();</span><br><span class="line">                if(t.right!=null&amp;&amp;t.right!=pre)</span><br><span class="line">                &#123;</span><br><span class="line">                    t = t.right;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    s.Pop();</span><br><span class="line">                    Console.Write(t.node + &quot; &quot;);</span><br><span class="line">                    pre = t;</span><br><span class="line">                    t = null;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 层序遍历</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;根节点&lt;/param&gt;</span><br><span class="line">        public void levelOrder(Tree root)</span><br><span class="line">        &#123;</span><br><span class="line">            if(root==null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            Queue&lt;Tree&gt; q = new Queue&lt;Tree&gt;();</span><br><span class="line">            Tree t = root;</span><br><span class="line">            q.Enqueue(t);</span><br><span class="line">            while(q.Count&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                t = q.Dequeue();</span><br><span class="line">                Console.Write(t.node + &quot; &quot;);</span><br><span class="line">                if(t.left!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.Enqueue(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                if(t.right!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.Enqueue(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Tree</span><br><span class="line">    &#123;</span><br><span class="line">        public string node;</span><br><span class="line">        public Tree left;</span><br><span class="line">        public Tree right;</span><br><span class="line">        public Tree(string node)</span><br><span class="line">        &#123;</span><br><span class="line">            this.node = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h2><p>森林的遍历只有两种：先序遍历和后序遍历，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace SuanFa</span><br><span class="line">&#123;</span><br><span class="line">    class Forest</span><br><span class="line">    &#123;</span><br><span class="line">       static void Main()</span><br><span class="line">        &#123;</span><br><span class="line">            Tree2 A = new Tree2(&quot;A&quot;);</span><br><span class="line">            Tree2 B = new Tree2(&quot;B&quot;);</span><br><span class="line">            Tree2 C = new Tree2(&quot;C&quot;);</span><br><span class="line">            Tree2 D = new Tree2(&quot;D&quot;);</span><br><span class="line">            Tree2 E = new Tree2(&quot;E&quot;);</span><br><span class="line">            Tree2 F = new Tree2(&quot;F&quot;);</span><br><span class="line">            Tree2 G = new Tree2(&quot;G&quot;);</span><br><span class="line">            Tree2 H = new Tree2(&quot;H&quot;);</span><br><span class="line">            Tree2 I = new Tree2(&quot;I&quot;);</span><br><span class="line">            A.t.Add(B);</span><br><span class="line">            A.t.Add(C);</span><br><span class="line">            A.t.Add(D);</span><br><span class="line">            A.t.Add(E);</span><br><span class="line">            A.t.Add(F);</span><br><span class="line">            A.t.Add(G);</span><br><span class="line">            B.t.Add(H);</span><br><span class="line">            B.t.Add(I);</span><br><span class="line">            Forest fr = new Forest();</span><br><span class="line">            fr.forestPre2(A);</span><br><span class="line">            fr.forestPre(A);</span><br><span class="line">            fr.forestPost(A);</span><br><span class="line">            fr.forestPost2(A);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 树的森林的先序遍历，递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;t&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void forestPre2(Tree2 t)</span><br><span class="line">        &#123;</span><br><span class="line">            if (t == null)</span><br><span class="line">                return;</span><br><span class="line">            Console.WriteLine(t.node);</span><br><span class="line">            foreach(Tree2 tt in t.t)</span><br><span class="line">            &#123;</span><br><span class="line">                forestPre2(tt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 树的森林的先序遍历，非递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void forestPre(Tree2 root)</span><br><span class="line">        &#123;</span><br><span class="line">            Tree2 tt = root;//根节点</span><br><span class="line">            Stack&lt;Tree2&gt; s = new Stack&lt;Tree2&gt;();</span><br><span class="line">            int[] whichChild = new int[200];//访问到该节点的第几个子节点</span><br><span class="line">            int index = 0;//栈中元素索引</span><br><span class="line">            while (tt != null || s.Count &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                if (tt != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(tt.node);//该节点输出</span><br><span class="line">                    s.Push(tt);//该节点入栈</span><br><span class="line">                    whichChild[index] = 0;//需要遍历该节点的子节点索引</span><br><span class="line">                    if (tt.t.Count &gt;0)//有子节点</span><br><span class="line">                    &#123;</span><br><span class="line">                        tt = tt.t[whichChild[index]];</span><br><span class="line">                        whichChild[index]++;//需要访问该节点的下一个子节点</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        tt = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    index++;//栈中下一个元素索引</span><br><span class="line">                &#125;</span><br><span class="line">                else if(whichChild[index-1]&lt;s.Peek().t.Count)//找该节点的兄弟节点</span><br><span class="line">                &#123;</span><br><span class="line">                    tt = s.Peek().t[whichChild[index-1]];//获取兄弟节点</span><br><span class="line">                    whichChild[index-1]++;//该节点的下一个兄弟节点的索引</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    s.Pop();//删除该节点</span><br><span class="line">                    index--;</span><br><span class="line">                    tt = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 森林的后序遍历，递归</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void forestPost(Tree2 root)</span><br><span class="line">        &#123;</span><br><span class="line">            if (root == null)</span><br><span class="line">                return;</span><br><span class="line">            foreach(Tree2 t in root.t)</span><br><span class="line">            &#123;</span><br><span class="line">                forestPost(t);</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(root.node);</span><br><span class="line">        &#125;</span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 森林的后序遍历，非递归，解释同上</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;root&quot;&gt;&lt;/param&gt;</span><br><span class="line">        public void forestPost2(Tree2 root)</span><br><span class="line">        &#123;</span><br><span class="line">            Tree2 tt = root;</span><br><span class="line">            Stack&lt;Tree2&gt; s = new Stack&lt;Tree2&gt;();</span><br><span class="line">            int[] whichChild = new int[200];</span><br><span class="line">            int index = 0;</span><br><span class="line">            while(tt!=null||s.Count&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                if(tt!=null)</span><br><span class="line">                &#123;</span><br><span class="line">                    s.Push(tt);</span><br><span class="line">                    whichChild[index]=0;</span><br><span class="line">                    if(tt.t.Count&gt;0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tt = tt.t[whichChild[index]];</span><br><span class="line">                        whichChild[index]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        tt = null;</span><br><span class="line">                    &#125;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(whichChild[index-1]&lt;s.Peek().t.Count)</span><br><span class="line">                &#123;</span><br><span class="line">                    tt = s.Peek().t[whichChild[index - 1]];</span><br><span class="line">                    whichChild[index-1]++;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    tt = s.Pop();</span><br><span class="line">                    Console.Write(tt.node);</span><br><span class="line">                    index--;</span><br><span class="line">                    tt = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    class Tree2</span><br><span class="line">    &#123;</span><br><span class="line">        public string node;</span><br><span class="line">        public List&lt;Tree2&gt; t = new List&lt;Tree2&gt;();</span><br><span class="line">        public Tree2(string node)</span><br><span class="line">        &#123;</span><br><span class="line">            this.node = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.jpg"
                alt="Wangzhuanxu" />
            
              <p class="site-author-name" itemprop="name">Wangzhuanxu</p>
              <p class="site-description motion-element" itemprop="description">经验+总结</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wangzhuanxu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>







        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    

  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'GTj5TU75m2FDiCuybEFbjRiU-gzGzoHsz',
        appKey: 'aYs53tL3qxCcS3LniPH51d5P',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
